target Cpp{
  //cmake-include: "mujoco.cmake",
};

public preamble {=
#include <mujoco/mujoco.h>
//#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include <string>
#include <array>
#include <thread>
#include <fstream>

#include "common/common_world_data.hpp"
#include "common/common_vector.hpp"

// structs that handle user input
struct KeyboardInput {
  GLFWwindow* window;
  int key;
  int scancode;
  int act;
  int mods;
};

struct MouseButtonInput {
  GLFWwindow* window;
  int button;
  int act;
  int mods;
};

struct MouseMoveInput {
  GLFWwindow* window;
  double xpos;
  double ypos;
};

struct ScrollInput {
  GLFWwindow* window;
  double xoffset;
  double yoffset;
};

=}

reactor RoboXArm7Sim(
  file: std::string = "",
  visualize: bool = true
  ) {
    private preamble {=
      mjvCamera global_camera{};   // abstract camera
      mjvOption global_options{};  // visualization options
      mjvScene global_scene{};     // abstract scene
      mjrContext global_context{}; // custom GPU context
      mjModel* global_model = nullptr;
      mjData* global_data = nullptr;
      bool global_button_left = false;
      bool global_button_middle = false;
      bool global_button_right = false;
      double global_lastx = 0;
      double global_lasty = 0;

      // keyboard callback
      void keyboard(GLFWwindow* window, int key, int scancode, int act, int mods) {
        std::cout << "KEYBOARD ACTION" << std::endl;

        // backspace: reset simulation
        if (act == GLFW_PRESS && key == GLFW_KEY_BACKSPACE) {
          mj_resetData(global_model, global_data);
          mj_forward(global_model, global_data);
        }
      }

      void mouse_button(GLFWwindow* window, int button, int act, int mods) {
        std::cout << "MOUSE BUTTON ACTION" << std::endl;
        // update button state
        global_button_left = (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS);
        global_button_middle = (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_MIDDLE) == GLFW_PRESS);
        global_button_right = (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS);

        // update mouse position
        glfwGetCursorPos(window, &global_lastx, &global_lasty);
      }

      void mouse_move(GLFWwindow* window, double xpos, double ypos) {
        std::cout << "MOUSE MOVE" << std::endl;
        // no buttons down: nothing to do
        if (!global_button_left && !global_button_middle && !global_button_right) {
          return;
        }

        // compute mouse displacement, save
        double dx = xpos - global_lastx;
        double dy = ypos - global_lasty;
        global_lastx = xpos;
        global_lasty = ypos;

        // get current window size
        int width, height;
        glfwGetWindowSize(window, &width, &height);

        // get shift key state
        bool mod_shift =
            (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS || glfwGetKey(window, GLFW_KEY_RIGHT_SHIFT) == GLFW_PRESS);

        // determine action based on mouse button
        mjtMouse action;
        if (global_button_right) {
          action = mod_shift ? mjMOUSE_MOVE_H : mjMOUSE_MOVE_V;
        } else if (global_button_left) {
          action = mod_shift ? mjMOUSE_ROTATE_H : mjMOUSE_ROTATE_V;
        } else {
          action = mjMOUSE_ZOOM;
        }

        // move camera
        mjv_moveCamera(global_model, action, dx / height, dy / height, &global_scene, &global_camera);
      }

      void scroll(GLFWwindow* window, double xoffset, double yoffset) {
        std::cout << "SCROLL" << std::endl;
        // emulate vertical mouse motion = 5% of window height
        mjv_moveCamera(global_model, mjMOUSE_ZOOM, 0, -0.05 * yoffset, &global_scene, &global_camera);
      }
    =}
  // simulator thread and pointer to glfw window other things are sadly globally defined
  state thread: std::thread;
  state error: {=char*=};
  state window: GLFWwindow*;
  state terminate: bool = false;

  // communicating controll inputs from controller to simulator thread
  state last_controll_input: Position;
  state last_controll_input_lock: std::mutex;
   
  input robo_next_position_checked: Position;
  output interface_world_data: WorldData;

  // the simulator thread pushes data into this physical action
  physical action world_data: WorldData;

  reaction initialize(startup) -> world_data {=
      std::cout << "Starting Simulator with: " << file << std::endl;
      this->error = new char[1000];

      // load model from file and check for errors
      global_model = mj_loadXML(file.c_str(), NULL, this->error, 1000);
      if (global_model == nullptr) {
        std::string str(error, 1000);
        std::cerr << "ERROR: " << str << std::endl;
        std::exit(1);
      } else {
        // make data corresponding to model
        global_data = mj_makeData(global_model);
      }


      mj_step(global_model, global_data);

      thread = std::thread([&]() {
        if (visualize) {
          // init GLFW, create window, make OpenGL contexttext current, request v-sync
          glfwInit();
          //gladLoadGL();
          window = glfwCreateWindow(1200, 900, "MujocoSimulator", NULL, NULL);
          glfwMakeContextCurrent(window);
          glfwSwapInterval(1);

          // initialize visualization data structures
          mjv_defaultCamera(&global_camera);
          mjv_defaultOption(&global_options);
          mjr_defaultContext(&global_context);

          // create scene and contexttext
          mjv_makeScene(global_model, &global_scene, 2000);
          mjr_makeContext(global_model, &global_context, mjFONTSCALE_150);

          // install GLFW mouse and keyboard callbacks
          glfwSetKeyCallback(window, keyboard);
          glfwSetCursorPosCallback(window, mouse_move);
          glfwSetMouseButtonCallback(window, mouse_button);
          glfwSetScrollCallback(window, scroll);

          // TODO: remove until bodyless methods are implemented
          // get framebuffer viewport
          mjrRect viewport = {0, 0, 0, 0};
          glfwGetFramebufferSize(window, &viewport.width, &viewport.height);
        }

        while (!this->terminate) {
          mj_step1(global_model, global_data);

          std::cout << "ADVANCING TIME: " << global_data->time << std::endl;

          {
            std::lock_guard<std::mutex> lock(this->last_controll_input_lock);
            auto coords = last_controll_input.get_coordinates();
            auto angles = last_controll_input.get_roll_pitch_yaw();

            global_data->ctrl[0] = coords.X_ / 1000.0;
            global_data->ctrl[1] = coords.Y_ / 1000.0;
            global_data->ctrl[2] = coords.Z_ / 1000.0;
            global_data->ctrl[3] = angles.X_ / 1000.0;
            global_data->ctrl[4] = angles.Y_ / 1000.0;
            global_data->ctrl[5] = angles.Z_ / 1000.0;
          }

          if (visualize) {
            // get framebuffer viewport
            mjrRect viewport = {0, 0, 0, 0};
            glfwGetFramebufferSize(window, &viewport.width, &viewport.height);

            // update scene and render
            mjv_updateScene(global_model, global_data, &global_options, NULL, &global_camera, mjCAT_ALL, &global_scene);
            mjr_render(viewport, &global_scene, &global_context);

            // swap OpenGL buffers (blocking call due to v-sync)
            glfwSwapBuffers(window);
            // process pending GUI events, call GLFW callbacks
            glfwPollEvents();

            if (glfwWindowShouldClose(window)) {
              exit(0);
            }
          }

          mj_step2(global_model, global_data);

          auto data = WorldData{global_data, global_model};

          world_data.schedule(data);
        }
      });
  =}

  reaction forward_world_data(world_data) -> interface_world_data {=
      interface_world_data.set(*world_data.get());
      
  =}

  reaction handle_controll_signals(robo_next_position_checked) {=
    std::cout << "getting signals" << std::endl;
    std::lock_guard<std::mutex> lock(this->last_controll_input_lock);
    last_controll_input = *robo_next_position_checked.get();
  =}

  reaction deconstruct(shutdown) {=
      terminate = false;
      thread.join();

      // free model and data
      mj_deleteData(global_data);
      mj_deleteModel(global_model);

      if (visualize) {
        // close GLFW, free visualization storage
        glfwTerminate();
        mjv_freeScene(&global_scene);
        mjr_freeContext(&global_context);
      }
  =}
}


