target Cpp

public preamble {=
  #ifndef SANITY_CHECKER
  #define SANITY_CHECKER
  #include "common_vector.hpp"

  #endif //SANITY_CHECKER
=}

reactor Planner(acceleration_cap: double = 0, max_step_length: double = 0) {

  private preamble {=

    Vector shorten_if_longer_than_max_step_length(Vector next_logical_step_offset_vector, double max_step_length){
      //reduce if the previous state was unstable
      if (next_logical_step_offset_vector.get_arithmetic_length() > max_step_length)
        next_logical_step_offset_vector = next_logical_step_offset_vector.normalize().scale(max_step_length);
      return next_logical_step_offset_vector;
    }

    VectorCollectionVelocityControl calculate_offset_vector_given_max_acceleration(Vector last_position, Vector current_position,
                                                                             Vector raw_instruction, double max_step_length, double acceleration_cap){
      VectorArithmetics va = VectorArithmetics{};                                                                        

      Vector next_logical_step_offset_vector = va.get_delta_vector(last_position, current_position);
      next_logical_step_offset_vector = shorten_if_longer_than_max_step_length(next_logical_step_offset_vector, max_step_length);
      std::cout << "Now the next_logical_step_offset_vector:";
      next_logical_step_offset_vector.to_string();

      Vector next_logical_step = va.add_vectors(current_position, next_logical_step_offset_vector);
      std::cout << "Now the next_logical_step:";
      next_logical_step.to_string();

      Vector acceleration_vector = va.get_delta_vector(next_logical_step, raw_instruction);
      std::cout << "Now the acceleration_vector (unshortnened):";
      acceleration_vector.to_string();
      if (acceleration_vector.get_arithmetic_length() > 0){acceleration_vector = acceleration_vector.normalize().scale(acceleration_cap);}     

      Vector offset_vector = va.add_vectors(next_logical_step_offset_vector, acceleration_vector);
      std::cout << "Now the offset_vector:";
      offset_vector.to_string();

      return VectorCollectionVelocityControl{next_logical_step_offset_vector, next_logical_step, acceleration_vector, offset_vector};
    }

   

  =}

  input planner_raw_instruction: Vector
  input planner_current_position: Vector
  input planner_last_position: Vector

  output velocity_control_vector_collection: VectorCollectionVelocityControl

  reaction(planner_current_position, planner_last_position, planner_raw_instruction) ->
  velocity_control_vector_collection {=
    Vector  vector_current_position = *planner_current_position.get();
    Vector  vector_last_position = *planner_last_position.get();
    Vector  vector_raw_instruction = *planner_raw_instruction.get();

    VectorCollectionVelocityControl vcvc = calculate_offset_vector_given_max_acceleration(vector_last_position, vector_current_position, vector_raw_instruction, max_step_length, acceleration_cap);

    velocity_control_vector_collection.set(vcvc);
  =}
}
