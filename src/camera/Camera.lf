target Cpp;

public preamble {=
  #ifndef CAMERA_LF
  #define CAMERA_LF

  #include "common_vector.hpp"
  #include "camera_library_includes.hpp"
  #include <librealsense2/rs.hpp>
  #include <iostream>
  #include <optional>

  #endif //CAMERA_LF
=}

private preamble {=

=}

reactor Camera(start_stream: time = 1s, frame_fetch_period: time = 5ms, stream_width: int = 0, stream_height: int = 0)
 {
  timer t(start_stream, frame_fetch_period)
  input camera_current_position: Position
  output offset_target: Position
  output controller_interface_target: Position

  state pipe: {=rs2::pipeline=}
  state texture: {=custom_benes_texture=}
  state app:{=window=}
  
  state coords3d_target_by_camera: std::optional<Vector> 
  state current_target: Position 



  reaction(startup) {=
    this->app = init_camera_generate_window(this->pipe, stream_width, stream_height);
  =}

  reaction(t)  {=
    this->coords3d_target_by_camera = receive_current_target(this->pipe);
  =}
  reaction(camera_current_position)-> controller_interface_target, offset_target {=
    Position position_current_position = *camera_current_position.get();

    if(this->coords3d_target_by_camera.has_value()){
      // target is set, target has to be reached out for
      std::cout << "Moving, there is a target: " << std::endl; 
      this->coords3d_target_by_camera.value().to_string();
      CoordinateTransformations ta = CoordinateTransformations{};
      Vector target = ta.transform_coordinates_wrapper(this->coords3d_target_by_camera.value(), position_current_position); 
      std::cout << "The corresponding coordinates:" << std::endl; 
      target.to_string();
      this->current_target = Position{target, Vector{0, 100 , 0 }};
      offset_target.set(this->current_target);
    }
    else {
      //target is not set, target is the current position
      std::cout << "Not moving, no target set" << std::endl; 
      offset_target.set(this->current_target);
    }
    =}
}
