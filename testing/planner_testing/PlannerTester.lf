target Cpp

public preamble {=
  #ifndef PLANNERTESTER
  #define PLANNERTESTER
  #include "common_vector.hpp"
  #include "random_vectors_handler.hpp"


  #endif //ROBOXARM
=}

reactor PlannerTester {
  input next_position_checked: Vector  // planner facing

  output planner_last_position: Vector
  output planner_current_position: Vector
  output planner_raw_instruction: Vector
  
  state current_last_position: Vector 
  state current_current_position: Vector
  state current_raw_instruction: Vector

  state random_vectors_index: int = 0;


  logical action la_next_position_checked: Vector

  reaction(startup)-> planner_raw_instruction, planner_current_position, planner_last_position{=

    RandomVectorsHandler rvH = RandomVectorsHandler{"testing/testing_input_data/random_vectors.csv"}; 
    //every row is a vector, but the row at position 0 is the header
    std::tuple<Vector, Vector, Vector> vectors = rvH.get_vector_triplet_at_position(0);

    current_last_position = std::get<0>(vectors);
    current_current_position = std::get<1>(vectors);
    current_raw_instruction = std::get<2>(vectors);
    

    planner_raw_instruction.set(current_raw_instruction);
    planner_current_position.set(current_current_position);
    planner_last_position.set(current_last_position);

    random_vectors_index = random_vectors_index + 1; 


  =}

  reaction(la_next_position_checked) -> planner_raw_instruction, planner_current_position, planner_last_position {=
   
    //get Vector out of input_port
    Vector next_position_checked = *la_next_position_checked.get();     
    VectorArithmetics va = VectorArithmetics{};

    //finished
    if(va.get_distance_between_point_vectors(next_position_checked,current_raw_instruction) <= 1){

      std::cout << "finished one trajectory" << std::endl;

      //sending new commands 
      // planner_raw_instruction.set(current_raw_instruction);
      // planner_current_position.set(current_current_position);
      // planner_last_position.set(current_last_position);

      
    }else {

      //state adaption since we are moving
      current_last_position = current_current_position; 
      current_current_position = next_position_checked;

      //sending new commands 
      planner_raw_instruction.set(current_raw_instruction);
      planner_current_position.set(current_current_position);
      planner_last_position.set(current_last_position);
  }

  =}

  reaction(next_position_checked)-> la_next_position_checked {= 
    la_next_position_checked.schedule(next_position_checked.get(),0ms);
   =}

}
