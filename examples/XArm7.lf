target Cpp{
    cmake-include: "mujoco.cmake",
    };

import XArm7Controll from "../src/hardware/xarm7_controller.lf";
// import MujocoSimulator from "../src/simulator/mujoco_simulator.lf";
import XArm7InterfaceSimulated from "../src/interface/XArmInterface.lf";
import SanityChecker from "../src/interface/SanityChecker.lf"


public preamble {=
#include <chrono>
#include "common_sanity_check.hpp"
=}

reactor RobotControl (stride: int  = 5, hypotenuse: int = 50)  {
    private preamble{= 
    #include <cmath>

    double calculate_x_value(int hypothenus, int angle_in_deg){
        double x_val = 0.0;
        x_val = hypothenus * cos(angle_in_deg*3.14159/180.0);
        return x_val;
        
    }

    double calculate_y_value(int hypothenus, int angle_in_deg){
        double y_val = 0.0;
        y_val = hypothenus * sin(angle_in_deg*3.14159/180.0);
        return y_val;   }
    
    =}
    state deg: int = 0;
    state last_position: Vector; 
    output instructions: PositionEvaluator;
    input controller_world_data: WorldData;        
    
    // timer t(2s,120 msec);

    state direction: bool;
    //logical action change_direction: void;

    reaction (startup) {=
        direction = false;
        srand(time(nullptr));
    =}

   
    reaction (controller_world_data) -> instructions{=

        // last_data = *controller_world_data.get(); 

        double _x_val = calculate_x_value(hypotenuse, deg ) + 400.0;
        double _y_val = calculate_y_value(hypotenuse, deg ) + 0.0;
        
        bool are_simulating = 0;

        if (are_simulating){
            //FIXME : this is not perfectly suiting the simulator
            auto current_world_data = *controller_world_data.get();
            Vector current_position = Vector(current_world_data.position().at(0),current_world_data.position().at(1), current_world_data.position().at(2)); 
            Vector new_position = Vector(0.3, -0.5, -0.3);
            PositionEvaluator pe = PositionEvaluator(current_position, new_position);
            instructions.set(pe);
            last_position = current_position; 

        }
        else {
            auto current_world_data = *controller_world_data.get();
            Vector current_position = Vector(current_world_data.position().at(0),current_world_data.position().at(1), current_world_data.position().at(2)); 
            Vector new_position = Vector(_x_val, _y_val, 200);
            PositionEvaluator pe = PositionEvaluator(current_position, new_position);
            instructions.set(pe);
            deg = (deg + stride) % 360;
            last_position = current_position; 
        }  
        
    
=}


}

main reactor XArm7{
    controller = new RobotControl();
    robo = new XArm7Controll();
    sanity_checker = new SanityChecker();
    // sim = new MujocoSimulator(file="./examples/models/xarm7/xarm7.xml");
    interface = new XArm7InterfaceSimulated();
    
    
    interface.robo_checked_instructions -> robo.robo_checked_instructions;
    robo.interface_world_data -> interface.interface_world_data;
   
    // interface.simulator_signals -> sim.controll_signals;
    // sim.simulator_world_data -> interface.simulator_world_data;


    controller.instructions -> sanity_checker.instructions;
    sanity_checker.checked_instructions -> interface.checked_instructions;
    interface.controller_world_data -> controller.controller_world_data;
}
